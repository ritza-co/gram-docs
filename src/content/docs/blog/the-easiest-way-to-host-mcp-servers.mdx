---
title: "The easiest way to host MCP servers"
description: "A practical guide to deploying MCP servers with the right transport, security, and hosting setup and how to simplify the process with Gram."
sidebar:
  order: 0
---

Tools like Speakeasy make it easy to build MCP servers, allowing developers to quickly integrate APIs and run MCP servers locally using clients like Claude or Cursor.

But hosting an MCP server is a little more complicated. You need to choose the right transport to expose your server, manage certificates to ensure secure communication, and handle authentication, distribution, scaling, and all the other challenges that come with deploying a server.

Because MCP is a new and evolving protocol with no established security guidelines and best practices, making a poor hosting decision can lead to security issues (like unwanted access) and increased technical debt, especially if you maintain the API the MCP server depends on.

The article explores the complexities of MCP server hosting and shows you how Gram can help you simplify, secure, and scale your deployment.

## Comparing local and hosted MCP servers

MCP makes it easy to run servers in other local environments. Using the MCP [Python](https://github.com/modelcontextprotocol/python-sdk), [TypeScript](https://github.com/modelcontextprotocol/typescript-sdk), or [Java](https://github.com/modelcontextprotocol/java-sdk) SDKs, you can package your application in a way that allows others to download the source code or executable and run the application locally using tools like Cursor or Claude.

Here's what a local setup looks like with a running MCP server and client.

![Running MCP server locally](/img/blog/the-easiest-way-to-host-mcp-servers/local-hosting.png)

Running an MCP server locally has several advantages:

- **Security:** Locally running MCP servers have no risk of external access or network exposure, especially if the MCP client (like Claude) is running on the same machine.
- **Easy setup:** There's no need to manage remote infrastructure, deploy to cloud environments, or configure complex networking.
- **Speed:** Like other local servers, MCP servers are naturally fast, with minimal latency and smooth iteration.

As MCP adoption grows, companies are increasingly hosting their own MCP servers to make them accessible to teammates, customers, and external agents. While local setups are great for quick iteration and personal use, they don't scale well. As your project grows, you'll need to make your MCP server publicly accessible, which means hosting it yourself.

Here's what the architecture looks like when the MCP server is hosted remotely and the client connects over the internet.

![Running MCP server remotely](/img/blog/the-easiest-way-to-host-mcp-servers/remote-hosting.png)

Hosting your MCP server remotely opens up new possibilities:

- **Instant access:** Users can connect to your MCP server without any local setup, removing friction and allowing tools like Claude or Cursor to work out of the box.
- **Distribution:** You can share your MCP server internally or externally without needing others to run it locally, speeding up onboarding and enabling broader adoption.
- **Monetization potential:** Hosting allows you to turn your MCP logic into a product, offering it as a paid integration or service – especially if it exposes valuable tools or APIs. 
- **Reliability and uptime:** Unlike a local setup that stops when your machine sleeps, a hosted server can stay online 24/7. You have a stable endpoint for your MCP server, ensuring consistent availability for users or agents.
- **Accessibility and team collaboration:** A hosted MCP server can be shared across teams or departments, making it easier to centralize tools and support cross-functional collaboration.
- **Scalability:** Like any production system, a hosted MCP server can be monitored, scaled, and secured, allowing you to handle growing traffic and multiple concurrent users.

MCP makes local hosting easy: Publish your server code and run it with a simple command. This portability drove the rapid adoption of MCP servers, especially as they're easy to configure with tools like Claude.

As companies begin building MCP servers for both internal teams and external users, they face a new challenge: How to scope and manage internal and public MCP servers?

## Comparing internal and public MCP servers

Internal and public MCP servers have different needs for access control, distribution, and maintainability.

### Scoping MCP tools by team or department

Different teams within an organization often use internal MCP servers for specific purposes:

- Marketing might query sales summaries.
- Design and engineering could fetch Figma specs, read code metadata, or autogenerate PRDs.

If multiple teams are using a single MCP server, scope creep becomes a risk. When one server has access to everything – every internal tool and every team's API – it creates a centralized dependency that's hard to maintain and potentially insecure. When one part breaks or leaks data, the whole system is compromised.

This kind of broad access makes scoping tools by team or use case essential. Platforms like FastMCP let you ignore certain endpoints from your OpenAPI document, but this often means spinning up multiple tailored MCP server instances, which can become tedious to manage with time.

### Client distribution models

Once your server is scoped for internal or public use, you need to consider how clients will access it.

**Internal distribution** typically involves setting up access controls and sharing the server with team-specific clients. This may include sharing Claude configuration templates, API keys, or secure endpoints.

**Public distribution** removes friction by exposing your MCP server over HTTPS, allowing any Claude user or agent to connect with no installation or configuration necessary. This approach works well for public APIs or low-risk services, and creates opportunities for monetization.

However, hosting an MCP server still comes with its own set of challenges:

- **Transport selection:** Unlike standard HTTP servers, MCP supports several transport options, including SSE, `stdio`, HTTP, and (with custom setup) WebSocket. While this range of options offers flexibility, it also requires careful consideration when it comes to choosing the right transport for your environment and deployment needs.
- **Security:** As a relatively new protocol, MCP lacks the mature security models of more established protocols. You'll need to manage SSL/TLS certificates, handle authentication, and implement scope control – all of which add complexity and contribute to long-term technical debt.
- **Maintenance and reliability:** Like any deployed service, an MCP server requires monitoring, updates, and infrastructure maintenance to ensure it stays available. You also need to ensure consistency across environments (like Claude, Cursor, and other agents), which adds to deployment overhead.

This is where Gram comes in, providing a streamlined solution for hosting, distributing, and managing MCP servers.

## Introducing Gram: Hosted MCP server in three simple steps

Gram takes your OpenAPI document and, in just three steps, generates a fully functional, scoped MCP server, ready to use across environments, teams, and agents.

![Running MCP server with Gram](/img/blog/the-easiest-way-to-host-mcp-servers/gram-ai-hosting.png)

Expose your MCP server as an internal or public service without managing infrastructure, while Gram handles hosting, distribution, and security.

Let's see how easy it is to create an MCP server with Gram.

### Create an MCP server

First, upload an OpenAPI document.

:::tip[NOTE]
The quality of your OpenAPI document directly impacts the quality of your MCP server. Learn about writing better OpenAPI documents in the [OpenAPI hub](https://www.speakeasy.com/openapi).
:::

<video width="600" controls>
  <source src="/img/blog/concepts/add-openapi-spec.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

Next, create a toolset.

A [toolset](https://docs.getgram.ai/concepts/toolsets) is a curated bundle of tools for a specific use case or team. In the Gram interface, you can select which tools to include and which to ignore based on your needs. 

<video width="600" controls>
  <source src="/img/blog/concepts/creating-a-toolset.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

Set environment variables.

Click **Environments** in the sidebar, and then **+ New Environment**.

<video width="600" controls>
  <source src="/img/blog/concepts/creating-environment.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

Now you can interact with your MCP server in real time in the Gram Playground.

![MCP playground](/img/blog/the-easiest-way-to-host-mcp-servers/gram-playground.png)

### Public and authenticated servers

To configure your MCP server as public or authenticated, go to **MCP** in the Playground sidebar and select **MCP Config** for your hosted server.

- A **public server** can be accessed from any machine and is well-suited for exposing non-sensitive use cases like public APIs or services that don't require authentication.

![Gram Public Server](/img/blog/the-easiest-way-to-host-mcp-servers/gram-public-server.png)

- An **authenticated server** requires a Gram API key in the project configuration, making it suitable for internal use cases where access needs to be restricted to authorized users.

![Gram Authenticated Server](/img/blog/the-easiest-way-to-host-mcp-servers/gram-authenticated-server.png)

### Connect your MCP server to AI agents

In addition to Claude, you can use your MCP server with AI agents. The Gram Python and TypeScript SDKs support OpenAI Agents, LangChain, and other function-based tooling.

Here is an example Python snippet that shows how to integrate your MCP server with LangChain:

```python
import asyncio
import os
from langchain import hub
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_openai_functions_agent
from gram_ai.langchain import GramLangchain

key = "<GRAM_API_KEY>"

gram = GramLangchain(api_key=key)

llm = ChatOpenAI(
    model="gpt-4",
    temperature=0,
    openai_api_key=os.getenv("OPENAI_API_KEY")
)

tools = gram.tools(
    project="default",
    toolset="marketing",
    environment="demo-environment",
)

prompt = hub.pull("hwchase17/openai-functions-agent")

agent = create_openai_functions_agent(llm=llm, tools=tools, prompt=prompt)

agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=False)

async def main():
    response = await agent_executor.ainvoke({
        "input": "Can you tell me about my tools?"
    })
    print(response)

if __name__ == "__main__":
    asyncio.run(main())
```

In the **Agents** tab in the Playground dashboard, you can build agentic workflows by selecting a language and integration type.

![Gram agents integration](/img/blog/the-easiest-way-to-host-mcp-servers/gram-agentic-workflow.png)


## Simplify MCP server hosting

Gram generates hosted MCP servers directly from OpenAPI documents, taking care of hosting, testing, distribution, and team-scoped toolsets so you don't need to manage infrastructure, scaling, or versioning.

Gram also offers:

- API key management
- Custom domains for distribution
- Integrations with popular platforms like Slack and GitHub

[Try Gram now](https://getgram.ai/) and see how easy it is to host and share your MCP server.
